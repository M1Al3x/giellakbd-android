diff -ru app/src/main/java/com/android/inputmethod/accessibility/MainKeyboardAccessibilityDelegate.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/accessibility/MainKeyboardAccessibilityDelegate.java
--- app/src/main/java/com/android/inputmethod/accessibility/MainKeyboardAccessibilityDelegate.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/accessibility/MainKeyboardAccessibilityDelegate.java	2017-05-27 13:16:01.000000000 +1000
@@ -110,7 +110,9 @@
      * Called when the keyboard is hidden and accessibility is enabled.
      */
     public void onHideWindow() {
-        announceKeyboardHidden();
+        if (mLastKeyboardMode != KEYBOARD_IS_HIDDEN) {
+            announceKeyboardHidden();
+        }
         mLastKeyboardMode = KEYBOARD_IS_HIDDEN;
     }
 
Only in app/src/main/java/com/android/inputmethod: annotations
Only in app/src/main/java/com/android/inputmethod/compat: AppWorkaroundsHelper.java
diff -ru app/src/main/java/com/android/inputmethod/compat/EditorInfoCompatUtils.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat/EditorInfoCompatUtils.java
--- app/src/main/java/com/android/inputmethod/compat/EditorInfoCompatUtils.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat/EditorInfoCompatUtils.java	2017-05-27 13:16:01.000000000 +1000
@@ -19,6 +19,7 @@
 import android.view.inputmethod.EditorInfo;
 
 import java.lang.reflect.Field;
+import java.util.Locale;
 
 public final class EditorInfoCompatUtils {
     // Note that EditorInfo.IME_FLAG_FORCE_ASCII has been introduced
@@ -27,6 +28,8 @@
             EditorInfo.class, "IME_FLAG_FORCE_ASCII");
     private static final Integer OBJ_IME_FLAG_FORCE_ASCII = (Integer) CompatUtils.getFieldValue(
             null /* receiver */, null /* defaultValue */, FIELD_IME_FLAG_FORCE_ASCII);
+    private static final Field FIELD_HINT_LOCALES = CompatUtils.getField(
+            EditorInfo.class, "hintLocales");
 
     private EditorInfoCompatUtils() {
         // This utility class is not publicly instantiable.
@@ -78,4 +81,18 @@
         }
         return (action != null) ? flags + action : flags.toString();
     }
+
+    public static Locale getPrimaryHintLocale(final EditorInfo editorInfo) {
+        if (editorInfo == null) {
+            return null;
+        }
+        final Object localeList = CompatUtils.getFieldValue(editorInfo, null, FIELD_HINT_LOCALES);
+        if (localeList == null) {
+            return null;
+        }
+        if (LocaleListCompatUtils.isEmpty(localeList)) {
+            return null;
+        }
+        return LocaleListCompatUtils.get(localeList, 0);
+    }
 }
diff -ru app/src/main/java/com/android/inputmethod/compat/InputMethodSubtypeCompatUtils.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat/InputMethodSubtypeCompatUtils.java
--- app/src/main/java/com/android/inputmethod/compat/InputMethodSubtypeCompatUtils.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat/InputMethodSubtypeCompatUtils.java	2017-05-27 13:16:01.000000000 +1000
@@ -17,14 +17,17 @@
 package com.android.inputmethod.compat;
 
 import android.os.Build;
+import android.text.TextUtils;
 import android.view.inputmethod.InputMethodSubtype;
 
 import com.android.inputmethod.annotations.UsedForTesting;
 import com.android.inputmethod.latin.RichInputMethodSubtype;
 import com.android.inputmethod.latin.common.Constants;
+import com.android.inputmethod.latin.common.LocaleUtils;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.Locale;
 
 import javax.annotation.Nonnull;
 
@@ -78,6 +81,21 @@
                 || subtype.containsExtraValueKey(Constants.Subtype.ExtraValue.ASCII_CAPABLE);
     }
 
+    // Note that InputMethodSubtype.getLanguageTag() is expected to be available in Android N+.
+    private static final Method GET_LANGUAGE_TAG =
+            CompatUtils.getMethod(InputMethodSubtype.class, "getLanguageTag");
+
+    public static Locale getLocaleObject(final InputMethodSubtype subtype) {
+        // Locale.forLanguageTag() is available only in Android L and later.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            final String languageTag = (String) CompatUtils.invoke(subtype, null, GET_LANGUAGE_TAG);
+            if (!TextUtils.isEmpty(languageTag)) {
+                return Locale.forLanguageTag(languageTag);
+            }
+        }
+        return LocaleUtils.constructLocaleFromString(subtype.getLocale());
+    }
+
     @UsedForTesting
     public static boolean isAsciiCapableWithAPI(final InputMethodSubtype subtype) {
         return (Boolean)CompatUtils.invoke(subtype, false, METHOD_isAsciiCapable);
Only in /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat: LocaleListCompatUtils.java
Only in /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/compat: UserManagerCompatUtils.java
Only in app/src/main/java/com/android/inputmethod/dictionarypack: DictionaryPackConstants.java
Only in app/src/main/java/com/android/inputmethod/dictionarypack: MetadataUriGetter.java
diff -ru app/src/main/java/com/android/inputmethod/keyboard/Key.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/Key.java
--- app/src/main/java/com/android/inputmethod/keyboard/Key.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/Key.java	2017-05-27 13:16:01.000000000 +1000
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2010 The Android Open Source Project
- * Copyright (C) 2015 Brendan Molloy <brendan@bbqsrc.net>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -40,7 +39,6 @@
 import com.android.inputmethod.latin.R;
 import com.android.inputmethod.latin.common.Constants;
 import com.android.inputmethod.latin.common.StringUtils;
-import com.android.inputmethod.latin.utils.TypefaceUtils;
 
 import java.util.Arrays;
 import java.util.Locale;
@@ -329,22 +327,9 @@
         moreKeys = MoreKeySpec.insertAdditionalMoreKeys(moreKeys, additionalMoreKeys);
         if (moreKeys != null) {
             actionFlags |= ACTION_FLAGS_ENABLE_LONG_PRESS;
-            MoreKeySpec[] mk = new MoreKeySpec[moreKeys.length];
-
-            int c = 0;
+            mMoreKeys = new MoreKeySpec[moreKeys.length];
             for (int i = 0; i < moreKeys.length; i++) {
-                if (TypefaceUtils.isGlyphDrawable(moreKeys[i])) {
-                    mk[c++] = new MoreKeySpec(moreKeys[i], needsToUpcase, localeForUpcasing);
-                }
-            }
-
-            if (c == 0) {
-                mMoreKeys = null;
-            } else if (c != mk.length) {
-                mMoreKeys = new MoreKeySpec[c];
-                System.arraycopy(mk, 0, mMoreKeys, 0, c);
-            } else {
-                mMoreKeys = mk;
+                mMoreKeys[i] = new MoreKeySpec(moreKeys[i], needsToUpcase, localeForUpcasing);
             }
         } else {
             mMoreKeys = null;
@@ -374,14 +359,9 @@
         } else {
             final String hintLabel = style.getString(
                     keyAttr, R.styleable.Keyboard_Key_keyHintLabel);
-            if (TypefaceUtils.isGlyphDrawable(hintLabel)) {
-                mHintLabel = needsToUpcase
-                        ? StringUtils.toTitleCaseOfKeyLabel(hintLabel, localeForUpcasing)
-                        : hintLabel;
-            } else {
-                mHintLabel = null;
-            }
-
+            mHintLabel = needsToUpcase
+                    ? StringUtils.toTitleCaseOfKeyLabel(hintLabel, localeForUpcasing)
+                    : hintLabel;
         }
         String outputText = KeySpecParser.getOutputText(keySpec);
         if (needsToUpcase) {
diff -ru app/src/main/java/com/android/inputmethod/keyboard/KeyboardId.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardId.java
--- app/src/main/java/com/android/inputmethod/keyboard/KeyboardId.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardId.java	2017-05-27 13:16:01.000000000 +1000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -60,6 +60,16 @@
     public static final int ELEMENT_EMOJI_CATEGORY4 = 14;
     public static final int ELEMENT_EMOJI_CATEGORY5 = 15;
     public static final int ELEMENT_EMOJI_CATEGORY6 = 16;
+    public static final int ELEMENT_EMOJI_CATEGORY7 = 17;
+    public static final int ELEMENT_EMOJI_CATEGORY8 = 18;
+    public static final int ELEMENT_EMOJI_CATEGORY9 = 19;
+    public static final int ELEMENT_EMOJI_CATEGORY10 = 20;
+    public static final int ELEMENT_EMOJI_CATEGORY11 = 21;
+    public static final int ELEMENT_EMOJI_CATEGORY12 = 22;
+    public static final int ELEMENT_EMOJI_CATEGORY13 = 23;
+    public static final int ELEMENT_EMOJI_CATEGORY14 = 24;
+    public static final int ELEMENT_EMOJI_CATEGORY15 = 25;
+    public static final int ELEMENT_EMOJI_CATEGORY16 = 26;
 
     public final RichInputMethodSubtype mSubtype;
     public final int mWidth;
@@ -225,6 +235,16 @@
         case ELEMENT_EMOJI_CATEGORY4: return "emojiCategory4";
         case ELEMENT_EMOJI_CATEGORY5: return "emojiCategory5";
         case ELEMENT_EMOJI_CATEGORY6: return "emojiCategory6";
+        case ELEMENT_EMOJI_CATEGORY7: return "emojiCategory7";
+        case ELEMENT_EMOJI_CATEGORY8: return "emojiCategory8";
+        case ELEMENT_EMOJI_CATEGORY9: return "emojiCategory9";
+        case ELEMENT_EMOJI_CATEGORY10: return "emojiCategory10";
+        case ELEMENT_EMOJI_CATEGORY11: return "emojiCategory11";
+        case ELEMENT_EMOJI_CATEGORY12: return "emojiCategory12";
+        case ELEMENT_EMOJI_CATEGORY13: return "emojiCategory13";
+        case ELEMENT_EMOJI_CATEGORY14: return "emojiCategory14";
+        case ELEMENT_EMOJI_CATEGORY15: return "emojiCategory15";
+        case ELEMENT_EMOJI_CATEGORY16: return "emojiCategory16";
         default: return null;
         }
     }
diff -ru app/src/main/java/com/android/inputmethod/keyboard/KeyboardLayoutSet.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardLayoutSet.java
--- app/src/main/java/com/android/inputmethod/keyboard/KeyboardLayoutSet.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardLayoutSet.java	2017-05-27 13:16:01.000000000 +1000
@@ -32,6 +32,7 @@
 
 import com.android.inputmethod.compat.EditorInfoCompatUtils;
 import com.android.inputmethod.compat.InputMethodSubtypeCompatUtils;
+import com.android.inputmethod.compat.UserManagerCompatUtils;
 import com.android.inputmethod.keyboard.internal.KeyboardBuilder;
 import com.android.inputmethod.keyboard.internal.KeyboardParams;
 import com.android.inputmethod.keyboard.internal.UniqueKeysCache;
@@ -275,6 +276,16 @@
             params.mIsPasswordField = InputTypeUtils.isPasswordInputType(editorInfo.inputType);
             params.mNoSettingsKey = InputAttributes.inPrivateImeOptions(
                     mPackageName, NO_SETTINGS_KEY, editorInfo);
+
+            // When the device is still unlocked, features like showing the IME setting app need to
+            // be locked down.
+            // TODO: Switch to {@code UserManagerCompat.isUserUnlocked()} in the support-v4 library
+            // when it becomes publicly available.
+            @UserManagerCompatUtils.LockState
+            final int lockState = UserManagerCompatUtils.getUserLockState(context);
+            if (lockState == UserManagerCompatUtils.LOCK_STATE_LOCKED) {
+                params.mNoSettingsKey = true;
+            }
         }
 
         public Builder setKeyboardGeometry(final int keyboardWidth, final int keyboardHeight) {
diff -ru app/src/main/java/com/android/inputmethod/keyboard/KeyboardSwitcher.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardSwitcher.java
--- app/src/main/java/com/android/inputmethod/keyboard/KeyboardSwitcher.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/KeyboardSwitcher.java	2017-05-27 13:16:01.000000000 +1000
@@ -44,6 +44,8 @@
 import com.android.inputmethod.latin.utils.ResourceUtils;
 import com.android.inputmethod.latin.utils.ScriptUtils;
 
+import javax.annotation.Nonnull;
+
 public final class KeyboardSwitcher implements KeyboardState.SwitchActions {
     private static final String TAG = KeyboardSwitcher.class.getSimpleName();
 
@@ -139,15 +141,18 @@
         }
     }
 
-    private void setKeyboard(final Keyboard keyboard) {
+    private void setKeyboard(
+            @Nonnull final int keyboardId,
+            @Nonnull final KeyboardSwitchState toggleState) {
         // Make {@link MainKeyboardView} visible and hide {@link EmojiPalettesView}.
         final SettingsValues currentSettingsValues = Settings.getInstance().getCurrent();
-        setMainKeyboardFrame(currentSettingsValues);
+        setMainKeyboardFrame(currentSettingsValues, toggleState);
         // TODO: pass this object to setKeyboard instead of getting the current values.
         final MainKeyboardView keyboardView = mKeyboardView;
         final Keyboard oldKeyboard = keyboardView.getKeyboard();
-        keyboardView.setKeyboard(keyboard);
-        mCurrentInputView.setKeyboardTopPadding(keyboard.mTopPadding);
+        final Keyboard newKeyboard = mKeyboardLayoutSet.getKeyboard(keyboardId);
+        keyboardView.setKeyboard(newKeyboard);
+        mCurrentInputView.setKeyboardTopPadding(newKeyboard.mTopPadding);
         keyboardView.setKeyPreviewPopupEnabled(
                 currentSettingsValues.mKeyPreviewPopupOn,
                 currentSettingsValues.mKeyPreviewPopupDismissDelay);
@@ -161,9 +166,9 @@
                 currentSettingsValues.mKeyPreviewDismissDuration);
         keyboardView.updateShortcutKey(mRichImm.isShortcutImeReady());
         final boolean subtypeChanged = (oldKeyboard == null)
-                || !keyboard.mId.mSubtype.equals(oldKeyboard.mId.mSubtype);
+                || !newKeyboard.mId.mSubtype.equals(oldKeyboard.mId.mSubtype);
         final int languageOnSpacebarFormatType = LanguageOnSpacebarUtils
-                .getLanguageOnSpacebarFormatType(keyboard.mId.mSubtype);
+                .getLanguageOnSpacebarFormatType(newKeyboard.mId.mSubtype);
         final boolean hasMultipleEnabledIMEsOrSubtypes = mRichImm
                 .hasMultipleEnabledIMEsOrSubtypes(true /* shouldIncludeAuxiliarySubtypes */);
         keyboardView.startDisplayLanguageOnSpacebar(subtypeChanged, languageOnSpacebarFormatType,
@@ -205,7 +210,7 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setAlphabetKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_ALPHABET));
+        setKeyboard(KeyboardId.ELEMENT_ALPHABET, KeyboardSwitchState.OTHER);
     }
 
     // Implements {@link KeyboardState.SwitchActions}.
@@ -214,7 +219,7 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setAlphabetManualShiftedKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_ALPHABET_MANUAL_SHIFTED));
+        setKeyboard(KeyboardId.ELEMENT_ALPHABET_MANUAL_SHIFTED, KeyboardSwitchState.OTHER);
     }
 
     // Implements {@link KeyboardState.SwitchActions}.
@@ -223,7 +228,7 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setAlphabetAutomaticShiftedKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_ALPHABET_AUTOMATIC_SHIFTED));
+        setKeyboard(KeyboardId.ELEMENT_ALPHABET_AUTOMATIC_SHIFTED, KeyboardSwitchState.OTHER);
     }
 
     // Implements {@link KeyboardState.SwitchActions}.
@@ -232,7 +237,7 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setAlphabetShiftLockedKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_ALPHABET_SHIFT_LOCKED));
+        setKeyboard(KeyboardId.ELEMENT_ALPHABET_SHIFT_LOCKED, KeyboardSwitchState.OTHER);
     }
 
     // Implements {@link KeyboardState.SwitchActions}.
@@ -241,7 +246,7 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setAlphabetShiftLockShiftedKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_ALPHABET_SHIFT_LOCK_SHIFTED));
+        setKeyboard(KeyboardId.ELEMENT_ALPHABET_SHIFT_LOCK_SHIFTED, KeyboardSwitchState.OTHER);
     }
 
     // Implements {@link KeyboardState.SwitchActions}.
@@ -250,11 +255,29 @@
         if (DEBUG_ACTION) {
             Log.d(TAG, "setSymbolsKeyboard");
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_SYMBOLS));
+        setKeyboard(KeyboardId.ELEMENT_SYMBOLS, KeyboardSwitchState.OTHER);
+    }
+
+    // Implements {@link KeyboardState.SwitchActions}.
+    @Override
+    public void setSymbolsShiftedKeyboard() {
+        if (DEBUG_ACTION) {
+            Log.d(TAG, "setSymbolsShiftedKeyboard");
+        }
+        setKeyboard(KeyboardId.ELEMENT_SYMBOLS_SHIFTED, KeyboardSwitchState.SYMBOLS_SHIFTED);
+    }
+
+    public boolean isImeSuppressedByHardwareKeyboard(
+            @Nonnull final SettingsValues settingsValues,
+            @Nonnull final KeyboardSwitchState toggleState) {
+        return settingsValues.mHasHardwareKeyboard && toggleState == KeyboardSwitchState.HIDDEN;
     }
 
-    private void setMainKeyboardFrame(final SettingsValues settingsValues) {
-        final int visibility = settingsValues.mHasHardwareKeyboard ? View.GONE : View.VISIBLE;
+    private void setMainKeyboardFrame(
+            @Nonnull final SettingsValues settingsValues,
+            @Nonnull final KeyboardSwitchState toggleState) {
+        final int visibility =  isImeSuppressedByHardwareKeyboard(settingsValues, toggleState)
+                ? View.GONE : View.VISIBLE;
         mKeyboardView.setVisibility(visibility);
         // The visibility of {@link #mKeyboardView} must be aligned with {@link #MainKeyboardFrame}.
         // @see #getVisibleKeyboardView() and
@@ -282,24 +305,55 @@
         mEmojiPalettesView.setVisibility(View.VISIBLE);
     }
 
-    public void onToggleEmojiKeyboard() {
-        final boolean needsToLoadKeyboard = (mKeyboardLayoutSet == null);
-        if (needsToLoadKeyboard || !isShowingEmojiPalettes()) {
-            mLatinIME.startShowingInputView(needsToLoadKeyboard);
-            setEmojiKeyboard();
-        } else {
-            mLatinIME.stopShowingInputView();
-            setAlphabetKeyboard();
+    public enum KeyboardSwitchState {
+        HIDDEN(-1),
+        SYMBOLS_SHIFTED(KeyboardId.ELEMENT_SYMBOLS_SHIFTED),
+        EMOJI(KeyboardId.ELEMENT_EMOJI_RECENTS),
+        OTHER(-1);
+
+        final int mKeyboardId;
+
+        KeyboardSwitchState(int keyboardId) {
+            mKeyboardId = keyboardId;
         }
     }
 
-    // Implements {@link KeyboardState.SwitchActions}.
-    @Override
-    public void setSymbolsShiftedKeyboard() {
-        if (DEBUG_ACTION) {
-            Log.d(TAG, "setSymbolsShiftedKeyboard");
+    public KeyboardSwitchState getKeyboardSwitchState() {
+        boolean hidden = !isShowingEmojiPalettes()
+                && (mKeyboardLayoutSet == null
+                || mKeyboardView == null
+                || !mKeyboardView.isShown());
+        KeyboardSwitchState state;
+        if (hidden) {
+            return KeyboardSwitchState.HIDDEN;
+        } else if (isShowingEmojiPalettes()) {
+            return KeyboardSwitchState.EMOJI;
+        } else if (isShowingKeyboardId(KeyboardId.ELEMENT_SYMBOLS_SHIFTED)) {
+            return KeyboardSwitchState.SYMBOLS_SHIFTED;
+        }
+        return KeyboardSwitchState.OTHER;
+    }
+
+    public void onToggleKeyboard(@Nonnull final KeyboardSwitchState toggleState) {
+        KeyboardSwitchState currentState = getKeyboardSwitchState();
+        Log.w(TAG, "onToggleKeyboard() : Current = " + currentState + " : Toggle = " + toggleState);
+        if (currentState == toggleState) {
+            mLatinIME.stopShowingInputView();
+            mLatinIME.hideWindow();
+            setAlphabetKeyboard();
+        } else {
+            mLatinIME.startShowingInputView(true);
+            if (toggleState == KeyboardSwitchState.EMOJI) {
+                setEmojiKeyboard();
+            } else {
+                mEmojiPalettesView.stopEmojiPalettes();
+                mEmojiPalettesView.setVisibility(View.GONE);
+
+                mMainKeyboardFrame.setVisibility(View.VISIBLE);
+                mKeyboardView.setVisibility(View.VISIBLE);
+                setKeyboard(toggleState.mKeyboardId, toggleState);
+            }
         }
-        setKeyboard(mKeyboardLayoutSet.getKeyboard(KeyboardId.ELEMENT_SYMBOLS_SHIFTED));
     }
 
     // Future method for requesting an updating to the shift state.
@@ -355,6 +409,19 @@
         mState.onEvent(event, currentAutoCapsState, currentRecapitalizeState);
     }
 
+    public boolean isShowingKeyboardId(@Nonnull int... keyboardIds) {
+        if (mKeyboardView == null || !mKeyboardView.isShown()) {
+            return false;
+        }
+        int activeKeyboardId = mKeyboardView.getKeyboard().mId.mElementId;
+        for (int keyboardId : keyboardIds) {
+            if (activeKeyboardId == keyboardId) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public boolean isShowingEmojiPalettes() {
         return mEmojiPalettesView != null && mEmojiPalettesView.isShown();
     }
diff -ru app/src/main/java/com/android/inputmethod/keyboard/emoji/EmojiCategory.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/emoji/EmojiCategory.java
--- app/src/main/java/com/android/inputmethod/keyboard/emoji/EmojiCategory.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/keyboard/emoji/EmojiCategory.java	2017-05-27 13:16:01.000000000 +1000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Android Open Source Project
+ * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
+import android.graphics.Paint;
 import android.graphics.Rect;
 import android.os.Build;
 import android.util.Log;
@@ -50,6 +51,16 @@
     private static final int ID_PLACES = 4;
     private static final int ID_SYMBOLS = 5;
     private static final int ID_EMOTICONS = 6;
+    private static final int ID_FLAGS = 7;
+    private static final int ID_EIGHT_SMILEY_PEOPLE = 8;
+    private static final int ID_EIGHT_ANIMALS_NATURE = 9;
+    private static final int ID_EIGHT_FOOD_DRINK = 10;
+    private static final int ID_EIGHT_TRAVEL_PLACES = 11;
+    private static final int ID_EIGHT_ACTIVITY = 12;
+    private static final int ID_EIGHT_OBJECTS = 13;
+    private static final int ID_EIGHT_SYMBOLS = 14;
+    private static final int ID_EIGHT_FLAGS = 15;
+    private static final int ID_EIGHT_SMILEY_PEOPLE_BORING = 16;
 
     public final class CategoryProperties {
         public final int mCategoryId;
@@ -67,7 +78,17 @@
             "nature",
             "places",
             "symbols",
-            "emoticons" };
+            "emoticons",
+            "flags",
+            "smiley & people",
+            "animals & nature",
+            "food & drink",
+            "travel & places",
+            "activity",
+            "objects2",
+            "symbols2",
+            "flags2",
+            "smiley & people2" };
 
     private static final int[] sCategoryTabIconAttr = {
             R.styleable.EmojiPalettesView_iconEmojiRecentsTab,
@@ -76,7 +97,17 @@
             R.styleable.EmojiPalettesView_iconEmojiCategory3Tab,
             R.styleable.EmojiPalettesView_iconEmojiCategory4Tab,
             R.styleable.EmojiPalettesView_iconEmojiCategory5Tab,
-            R.styleable.EmojiPalettesView_iconEmojiCategory6Tab };
+            R.styleable.EmojiPalettesView_iconEmojiCategory6Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory7Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory8Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory9Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory10Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory11Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory12Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory13Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory14Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory15Tab,
+            R.styleable.EmojiPalettesView_iconEmojiCategory16Tab };
 
     private static final int[] sAccessibilityDescriptionResourceIdsForCategories = {
             R.string.spoken_descrption_emoji_category_recents,
@@ -85,7 +116,17 @@
             R.string.spoken_descrption_emoji_category_nature,
             R.string.spoken_descrption_emoji_category_places,
             R.string.spoken_descrption_emoji_category_symbols,
-            R.string.spoken_descrption_emoji_category_emoticons };
+            R.string.spoken_descrption_emoji_category_emoticons,
+            R.string.spoken_descrption_emoji_category_flags,
+            R.string.spoken_descrption_emoji_category_eight_smiley_people,
+            R.string.spoken_descrption_emoji_category_eight_animals_nature,
+            R.string.spoken_descrption_emoji_category_eight_food_drink,
+            R.string.spoken_descrption_emoji_category_eight_travel_places,
+            R.string.spoken_descrption_emoji_category_eight_activity,
+            R.string.spoken_descrption_emoji_category_objects,
+            R.string.spoken_descrption_emoji_category_symbols,
+            R.string.spoken_descrption_emoji_category_flags,
+            R.string.spoken_descrption_emoji_category_eight_smiley_people };
 
     private static final int[] sCategoryElementId = {
             KeyboardId.ELEMENT_EMOJI_RECENTS,
@@ -94,7 +135,17 @@
             KeyboardId.ELEMENT_EMOJI_CATEGORY3,
             KeyboardId.ELEMENT_EMOJI_CATEGORY4,
             KeyboardId.ELEMENT_EMOJI_CATEGORY5,
-            KeyboardId.ELEMENT_EMOJI_CATEGORY6 };
+            KeyboardId.ELEMENT_EMOJI_CATEGORY6,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY7,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY8,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY9,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY10,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY11,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY12,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY13,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY14,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY15,
+            KeyboardId.ELEMENT_EMOJI_CATEGORY16 };
 
     private final SharedPreferences mPrefs;
     private final Resources mRes;
@@ -120,32 +171,70 @@
             mCategoryTabIconId[i] = emojiPaletteViewAttr.getResourceId(
                     sCategoryTabIconAttr[i], 0);
         }
+
+        int defaultCategoryId = EmojiCategory.ID_SYMBOLS;
         addShownCategoryId(EmojiCategory.ID_RECENTS);
         if (BuildCompatUtils.EFFECTIVE_SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            addShownCategoryId(EmojiCategory.ID_PEOPLE);
-            addShownCategoryId(EmojiCategory.ID_OBJECTS);
-            addShownCategoryId(EmojiCategory.ID_NATURE);
-            addShownCategoryId(EmojiCategory.ID_PLACES);
-            mCurrentCategoryId =
-                    Settings.readLastShownEmojiCategoryId(mPrefs, EmojiCategory.ID_PEOPLE);
+            if (canShowUnicodeEightEmoji()) {
+                defaultCategoryId = EmojiCategory.ID_EIGHT_SMILEY_PEOPLE;
+                addShownCategoryId(EmojiCategory.ID_EIGHT_SMILEY_PEOPLE);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_ANIMALS_NATURE);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_FOOD_DRINK);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_TRAVEL_PLACES);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_ACTIVITY);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_OBJECTS);
+                addShownCategoryId(EmojiCategory.ID_EIGHT_SYMBOLS);
+                addShownCategoryId(EmojiCategory.ID_FLAGS); // Exclude combinations without glyphs.
+            } else {
+                defaultCategoryId = EmojiCategory.ID_PEOPLE;
+                addShownCategoryId(EmojiCategory.ID_PEOPLE);
+                addShownCategoryId(EmojiCategory.ID_OBJECTS);
+                addShownCategoryId(EmojiCategory.ID_NATURE);
+                addShownCategoryId(EmojiCategory.ID_PLACES);
+                addShownCategoryId(EmojiCategory.ID_SYMBOLS);
+                if (canShowFlagEmoji()) {
+                    addShownCategoryId(EmojiCategory.ID_FLAGS);
+                }
+            }
         } else {
-            mCurrentCategoryId =
-                    Settings.readLastShownEmojiCategoryId(mPrefs, EmojiCategory.ID_SYMBOLS);
+            addShownCategoryId(EmojiCategory.ID_SYMBOLS);
         }
-        addShownCategoryId(EmojiCategory.ID_SYMBOLS);
         addShownCategoryId(EmojiCategory.ID_EMOTICONS);
-        getKeyboard(EmojiCategory.ID_RECENTS, 0 /* cagetoryPageId */)
-                .loadRecentKeys(mCategoryKeyboardMap.values());
+
+        DynamicGridKeyboard recentsKbd =
+                getKeyboard(EmojiCategory.ID_RECENTS, 0 /* categoryPageId */);
+        recentsKbd.loadRecentKeys(mCategoryKeyboardMap.values());
+
+        mCurrentCategoryId = Settings.readLastShownEmojiCategoryId(mPrefs, defaultCategoryId);
+        Log.i(TAG, "Last Emoji category id is " + mCurrentCategoryId);
+        if (!isShownCategoryId(mCurrentCategoryId)) {
+            Log.i(TAG, "Last emoji category " + mCurrentCategoryId +
+                    " is invalid, starting in " + defaultCategoryId);
+            mCurrentCategoryId = defaultCategoryId;
+        } else if (mCurrentCategoryId == EmojiCategory.ID_RECENTS &&
+                recentsKbd.getSortedKeys().isEmpty()) {
+            Log.i(TAG, "No recent emojis found, starting in category " + defaultCategoryId);
+            mCurrentCategoryId = defaultCategoryId;
+        }
     }
 
     private void addShownCategoryId(final int categoryId) {
         // Load a keyboard of categoryId
-        getKeyboard(categoryId, 0 /* cagetoryPageId */);
+        getKeyboard(categoryId, 0 /* categoryPageId */);
         final CategoryProperties properties =
                 new CategoryProperties(categoryId, getCategoryPageCount(categoryId));
         mShownCategories.add(properties);
     }
 
+    private boolean isShownCategoryId(final int categoryId) {
+        for (final CategoryProperties prop : mShownCategories) {
+            if (prop.mCategoryId == categoryId) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public static String getCategoryName(final int categoryId, final int categoryPageId) {
         return sCategoryName[categoryId] + "-" + categoryPageId;
     }
@@ -275,16 +364,16 @@
 
     public DynamicGridKeyboard getKeyboard(final int categoryId, final int id) {
         synchronized (mCategoryKeyboardMap) {
-            final Long categotyKeyboardMapKey = getCategoryKeyboardMapKey(categoryId, id);
-            if (mCategoryKeyboardMap.containsKey(categotyKeyboardMapKey)) {
-                return mCategoryKeyboardMap.get(categotyKeyboardMapKey);
+            final Long categoryKeyboardMapKey = getCategoryKeyboardMapKey(categoryId, id);
+            if (mCategoryKeyboardMap.containsKey(categoryKeyboardMapKey)) {
+                return mCategoryKeyboardMap.get(categoryKeyboardMapKey);
             }
 
             if (categoryId == EmojiCategory.ID_RECENTS) {
                 final DynamicGridKeyboard kbd = new DynamicGridKeyboard(mPrefs,
                         mLayoutSet.getKeyboard(KeyboardId.ELEMENT_EMOJI_RECENTS),
                         mMaxPageKeyCount, categoryId);
-                mCategoryKeyboardMap.put(categotyKeyboardMapKey, kbd);
+                mCategoryKeyboardMap.put(categoryKeyboardMapKey, kbd);
                 return kbd;
             }
 
@@ -304,7 +393,7 @@
                 mCategoryKeyboardMap.put(
                         getCategoryKeyboardMapKey(categoryId, pageId), tempKeyboard);
             }
-            return mCategoryKeyboardMap.get(categotyKeyboardMapKey);
+            return mCategoryKeyboardMap.get(categoryKeyboardMapKey);
         }
     }
 
@@ -348,4 +437,34 @@
         }
         return retval;
     }
+
+    private static boolean canShowFlagEmoji() {
+        Paint paint = new Paint();
+        String switzerland = "\uD83C\uDDE8\uD83C\uDDED"; //  U+1F1E8 U+1F1ED Flag for Switzerland
+        try {
+            return paint.hasGlyph(switzerland);
+        } catch (NoSuchMethodError e) {
+            // Compare display width of single-codepoint emoji to width of flag emoji to determine
+            // whether flag is rendered as single glyph or two adjacent regional indicator symbols.
+            float flagWidth = paint.measureText(switzerland);
+            float standardWidth = paint.measureText("\uD83D\uDC27"); //  U+1F427 Penguin
+            return flagWidth < standardWidth * 1.25;
+            // This assumes that a valid glyph for the flag emoji must be less than 1.25 times
+            // the width of the penguin.
+        }
+    }
+
+    private static boolean canShowUnicodeEightEmoji() {
+        Paint paint = new Paint();
+        String cheese = "\uD83E\uDDC0"; //  U+1F9C0 Cheese wedge
+        try {
+            return paint.hasGlyph(cheese);
+        } catch (NoSuchMethodError e) {
+            float cheeseWidth = paint.measureText(cheese);
+            float tofuWidth = paint.measureText("\uFFFE");
+            return cheeseWidth > tofuWidth;
+            // This assumes that a valid glyph for the cheese wedge must be greater than the width
+            // of the noncharacter.
+        }
+    }
 }
Only in app/src/main/java/com/android/inputmethod/latin: DictionaryFacilitatorProvider.java
diff -ru app/src/main/java/com/android/inputmethod/latin/EmojiAltPhysicalKeyDetector.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/EmojiAltPhysicalKeyDetector.java
--- app/src/main/java/com/android/inputmethod/latin/EmojiAltPhysicalKeyDetector.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/EmojiAltPhysicalKeyDetector.java	2017-05-27 13:16:01.000000000 +1000
@@ -16,92 +16,192 @@
 
 package com.android.inputmethod.latin;
 
+import android.content.res.Resources;
 import android.util.Log;
+import android.util.Pair;
 import android.view.KeyEvent;
 
 import com.android.inputmethod.keyboard.KeyboardSwitcher;
 import com.android.inputmethod.latin.settings.Settings;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.Nonnull;
+
 /**
  * A class for detecting Emoji-Alt physical key.
  */
 final class EmojiAltPhysicalKeyDetector {
     private static final String TAG = "EmojiAltPhysicalKeyDetector";
+    private static final boolean DEBUG = false;
 
-    private final RichInputConnection mRichInputConnection;
+    private List<EmojiHotKeys> mHotKeysList;
 
-    // True if the Alt key has been used as a modifier. In this case the Alt key up isn't
-    // recognized as an emoji key.
-    private boolean mAltHasBeenUsedAsAModifier;
+    private static class HotKeySet extends HashSet<Pair<Integer, Integer>> { };
 
-    public EmojiAltPhysicalKeyDetector(final RichInputConnection richInputConnection) {
-        mRichInputConnection = richInputConnection;
-    }
-
-    /**
-     * Record a down key event.
-     * @param keyEvent a down key event.
-     */
-    public void onKeyDown(final KeyEvent keyEvent) {
-        if (isAltKey(keyEvent)) {
-            mAltHasBeenUsedAsAModifier = false;
-        }
-        if (containsAltModifier(keyEvent)) {
-            mAltHasBeenUsedAsAModifier = true;
+    private abstract class EmojiHotKeys {
+        private final String mName;
+        private final HotKeySet mKeySet;
+
+        boolean mCanFire;
+        int mMetaState;
+
+        public EmojiHotKeys(final String name, HotKeySet keySet) {
+            mName = name;
+            mKeySet = keySet;
+            mCanFire = false;
+        }
+
+        public void onKeyDown(@Nonnull final KeyEvent keyEvent) {
+            if (DEBUG) {
+                Log.d(TAG, "EmojiHotKeys.onKeyDown() - " + mName + " - considering " + keyEvent);
+            }
+
+            final Pair<Integer, Integer> key =
+                    Pair.create(keyEvent.getKeyCode(), keyEvent.getMetaState());
+            if (mKeySet.contains(key)) {
+                if (DEBUG) {
+                   Log.d(TAG, "EmojiHotKeys.onKeyDown() - " + mName + " - enabling action");
+                }
+                mCanFire = true;
+                mMetaState = keyEvent.getMetaState();
+            } else if (mCanFire) {
+                if (DEBUG) {
+                   Log.d(TAG, "EmojiHotKeys.onKeyDown() - " + mName + " - disabling action");
+                }
+                mCanFire = false;
+            }
+        }
+
+        public void onKeyUp(@Nonnull final KeyEvent keyEvent) {
+            if (DEBUG) {
+                Log.d(TAG, "EmojiHotKeys.onKeyUp() - " + mName + " - considering " + keyEvent);
+            }
+
+            final int keyCode = keyEvent.getKeyCode();
+            int metaState = keyEvent.getMetaState();
+            if (KeyEvent.isModifierKey(keyCode)) {
+                 // Try restoring meta stat in case the released key was a modifier.
+                 // I am sure one can come up with scenarios to break this, but it
+                 // seems to work well in practice.
+                 metaState |= mMetaState;
+            }
+
+            final Pair<Integer, Integer> key = Pair.create(keyCode, metaState);
+            if (mKeySet.contains(key)) {
+                if (mCanFire) {
+                    if (!keyEvent.isCanceled()) {
+                        if (DEBUG) {
+                            Log.d(TAG, "EmojiHotKeys.onKeyUp() - " + mName + " - firing action");
+                        }
+                        action();
+                    } else {
+                        // This key up event was a part of key combinations and
+                        // should be ignored.
+                        if (DEBUG) {
+                            Log.d(TAG, "EmojiHotKeys.onKeyUp() - " + mName + " - canceled, ignoring action");
+                        }
+                    }
+                    mCanFire = false;
+                }
+            }
+
+            if (mCanFire) {
+                if (DEBUG) {
+                    Log.d(TAG, "EmojiHotKeys.onKeyUp() - " + mName + " - disabling action");
+                }
+                mCanFire = false;
+            }
+        }
+
+        protected abstract void action();
+    }
+
+    public EmojiAltPhysicalKeyDetector(@Nonnull final Resources resources) {
+        mHotKeysList = new ArrayList<EmojiHotKeys>();
+
+        final HotKeySet emojiSwitchSet = parseHotKeys(
+                resources, R.array.keyboard_switcher_emoji);
+        final EmojiHotKeys emojiHotKeys = new EmojiHotKeys("emoji", emojiSwitchSet) {
+            @Override
+            protected void action() {
+                final KeyboardSwitcher switcher = KeyboardSwitcher.getInstance();
+                switcher.onToggleKeyboard(KeyboardSwitcher.KeyboardSwitchState.EMOJI);
+            }
+        };
+        mHotKeysList.add(emojiHotKeys);
+
+        final HotKeySet symbolsSwitchSet = parseHotKeys(
+                resources, R.array.keyboard_switcher_symbols_shifted);
+        final EmojiHotKeys symbolsHotKeys = new EmojiHotKeys("symbols", symbolsSwitchSet) {
+            @Override
+            protected void action() {
+                final KeyboardSwitcher switcher = KeyboardSwitcher.getInstance();
+                switcher.onToggleKeyboard(KeyboardSwitcher.KeyboardSwitchState.SYMBOLS_SHIFTED);
+            }
+        };
+        mHotKeysList.add(symbolsHotKeys);
+    }
+
+    public void onKeyDown(@Nonnull final KeyEvent keyEvent) {
+        if (DEBUG) {
+            Log.d(TAG, "onKeyDown(): " + keyEvent);
+        }
+
+        if (shouldProcessEvent(keyEvent)) {
+            for (EmojiHotKeys hotKeys : mHotKeysList) {
+                hotKeys.onKeyDown(keyEvent);
+            }
+        }
+    }
+
+    public void onKeyUp(@Nonnull final KeyEvent keyEvent) {
+        if (DEBUG) {
+            Log.d(TAG, "onKeyUp(): " + keyEvent);
+        }
+
+        if (shouldProcessEvent(keyEvent)) {
+            for (EmojiHotKeys hotKeys : mHotKeysList) {
+                hotKeys.onKeyUp(keyEvent);
+            }
         }
     }
 
-    /**
-     * Determine whether an up key event is a special key up or not.
-     * @param keyEvent an up key event.
-     */
-    public void onKeyUp(final KeyEvent keyEvent) {
-        if (keyEvent.isCanceled()) {
-            // This key up event was a part of key combinations and should be ignored.
-            return;
-        }
-        if (!isAltKey(keyEvent)) {
-            mAltHasBeenUsedAsAModifier |= containsAltModifier(keyEvent);
-            return;
-        }
-        if (containsAltModifier(keyEvent)) {
-            mAltHasBeenUsedAsAModifier = true;
-            return;
-        }
+    private static boolean shouldProcessEvent(@Nonnull final KeyEvent keyEvent) {
         if (!Settings.getInstance().getCurrent().mEnableEmojiAltPhysicalKey) {
-            return;
-        }
-        if (mAltHasBeenUsedAsAModifier) {
-            return;
-        }
-        if (!mRichInputConnection.isConnected()) {
-            Log.w(TAG, "onKeyUp() : No connection to text view");
-            return;
-        }
-        onEmojiAltKeyDetected();
-    }
-
-    private static void onEmojiAltKeyDetected() {
-        KeyboardSwitcher.getInstance().onToggleEmojiKeyboard();
-    }
-
-    private static boolean isAltKey(final KeyEvent keyEvent) {
-        final int keyCode = keyEvent.getKeyCode();
-        return keyCode == KeyEvent.KEYCODE_ALT_LEFT || keyCode == KeyEvent.KEYCODE_ALT_RIGHT;
-    }
-
-    private static boolean containsAltModifier(final KeyEvent keyEvent) {
-        final int metaState = keyEvent.getMetaState();
-        // TODO: Support multiple keyboards. Take device id into account.
-        switch (keyEvent.getKeyCode()) {
-        case KeyEvent.KEYCODE_ALT_LEFT:
-            // Return true if Left-Alt is pressed with Right-Alt pressed.
-            return (metaState & KeyEvent.META_ALT_RIGHT_ON) != 0;
-        case KeyEvent.KEYCODE_ALT_RIGHT:
-            // Return true if Right-Alt is pressed with Left-Alt pressed.
-            return (metaState & KeyEvent.META_ALT_LEFT_ON) != 0;
-        default:
-            return (metaState & (KeyEvent.META_ALT_LEFT_ON | KeyEvent.META_ALT_RIGHT_ON)) != 0;
+            // The feature is disabled.
+            if (DEBUG) {
+                Log.d(TAG, "shouldProcessEvent(): Disabled");
+            }
+            return false;
+        }
+
+        return true;
+    }
+
+    private static HotKeySet parseHotKeys(
+            @Nonnull final Resources resources, final int resourceId) {
+        final HotKeySet keySet = new HotKeySet();
+        final String name = resources.getResourceEntryName(resourceId);
+        final String[] values = resources.getStringArray(resourceId);
+        for (int i = 0; values != null && i < values.length; i++) {
+            String[] valuePair = values[i].split(",");
+            if (valuePair.length != 2) {
+                Log.w(TAG, "Expected 2 integers in " + name + "[" + i + "] : " + values[i]);
+            }
+            try {
+                final Integer keyCode = Integer.parseInt(valuePair[0]);
+                final Integer metaState = Integer.parseInt(valuePair[1]);
+                final Pair<Integer, Integer> key = Pair.create(
+                        keyCode, KeyEvent.normalizeMetaState(metaState));
+                keySet.add(key);
+            } catch (NumberFormatException e) {
+                Log.w(TAG, "Failed to parse " + name + "[" + i + "] : " + values[i], e);
+            }
         }
+        return keySet;
     }
 }
diff -ru app/src/main/java/com/android/inputmethod/latin/LatinIME.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/LatinIME.java
--- app/src/main/java/com/android/inputmethod/latin/LatinIME.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/LatinIME.java	2017-05-27 13:16:01.000000000 +1000
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
- * Copyright (C) 2015 Brendan Molloy <brendan@bbqsrc.net>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,8 +30,10 @@
 import android.content.IntentFilter;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.graphics.Color;
 import android.inputmethodservice.InputMethodService;
 import android.media.AudioManager;
+import android.os.Build;
 import android.os.Debug;
 import android.os.IBinder;
 import android.os.Message;
@@ -54,7 +55,10 @@
 
 import com.android.inputmethod.accessibility.AccessibilityUtils;
 import com.android.inputmethod.annotations.UsedForTesting;
+import com.android.inputmethod.compat.BuildCompatUtils;
+import com.android.inputmethod.compat.EditorInfoCompatUtils;
 import com.android.inputmethod.compat.InputMethodServiceCompatUtils;
+import com.android.inputmethod.compat.InputMethodSubtypeCompatUtils;
 import com.android.inputmethod.compat.ViewOutlineProviderCompatUtils;
 import com.android.inputmethod.compat.ViewOutlineProviderCompatUtils.InsetsUpdater;
 import com.android.inputmethod.dictionarypack.DictionaryPackConstants;
@@ -93,7 +97,6 @@
 import com.android.inputmethod.latin.utils.StatsUtilsManager;
 import com.android.inputmethod.latin.utils.SubtypeLocaleUtils;
 import com.android.inputmethod.latin.utils.ViewLayoutUtils;
-import com.android.inputmethod.latin.utils.TypefaceUtils;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -144,8 +147,7 @@
     private RichInputMethodManager mRichImm;
     @UsedForTesting final KeyboardSwitcher mKeyboardSwitcher;
     private final SubtypeState mSubtypeState = new SubtypeState();
-    private final EmojiAltPhysicalKeyDetector mEmojiAltPhysicalKeyDetector =
-            new EmojiAltPhysicalKeyDetector(mInputLogic.mConnection);
+    private EmojiAltPhysicalKeyDetector mEmojiAltPhysicalKeyDetector;
     private StatsUtilsManager mStatsUtilsManager;
     // Working variable for {@link #startShowingInputView()} and
     // {@link #onEvaluateInputViewShown()}.
@@ -178,8 +180,9 @@
         private static final int MSG_WAIT_FOR_DICTIONARY_LOAD = 8;
         private static final int MSG_DEALLOCATE_MEMORY = 9;
         private static final int MSG_RESUME_SUGGESTIONS_FOR_START_INPUT = 10;
+        private static final int MSG_SWITCH_LANGUAGE_AUTOMATICALLY = 11;
         // Update this when adding new messages
-        private static final int MSG_LAST = MSG_RESUME_SUGGESTIONS_FOR_START_INPUT;
+        private static final int MSG_LAST = MSG_SWITCH_LANGUAGE_AUTOMATICALLY;
 
         private static final int ARG1_NOT_GESTURE_INPUT = 0;
         private static final int ARG1_DISMISS_GESTURE_FLOATING_PREVIEW_TEXT = 1;
@@ -273,6 +276,9 @@
             case MSG_DEALLOCATE_MEMORY:
                 latinIme.deallocateMemory();
                 break;
+            case MSG_SWITCH_LANGUAGE_AUTOMATICALLY:
+                latinIme.switchLanguage((InputMethodSubtype)msg.obj);
+                break;
             }
         }
 
@@ -391,6 +397,10 @@
             obtainMessage(MSG_UPDATE_TAIL_BATCH_INPUT_COMPLETED, suggestedWords).sendToTarget();
         }
 
+        public void postSwitchLanguage(final InputMethodSubtype subtype) {
+            obtainMessage(MSG_SWITCH_LANGUAGE_AUTOMATICALLY, subtype).sendToTarget();
+        }
+
         // Working variables for the following methods.
         private boolean mIsOrientationChanging;
         private boolean mPendingSuccessiveImsCallback;
@@ -556,7 +566,6 @@
         AudioAndHapticFeedbackManager.init(this);
         AccessibilityUtils.init(this);
         mStatsUtilsManager.onCreate(this /* context */, mDictionaryFacilitator);
-        TypefaceUtils.init(this);
         super.onCreate();
 
         mHandler.onCreate();
@@ -705,6 +714,12 @@
         mInputLogic.recycle();
     }
 
+    private boolean isImeSuppressedByHardwareKeyboard() {
+        final KeyboardSwitcher switcher = KeyboardSwitcher.getInstance();
+        return !onEvaluateInputViewShown() && switcher.isImeSuppressedByHardwareKeyboard(
+                mSettings.getCurrent(), switcher.getKeyboardSwitchState());
+    }
+
     @Override
     public void onConfigurationChanged(final Configuration conf) {
         SettingsValues settingsValues = mSettings.getCurrent();
@@ -719,7 +734,7 @@
             // have a change in hardware keyboard configuration.
             loadSettings();
             settingsValues = mSettings.getCurrent();
-            if (settingsValues.mHasHardwareKeyboard) {
+            if (isImeSuppressedByHardwareKeyboard()) {
                 // We call cleanupInternalStateForFinishInput() because it's the right thing to do;
                 // however, it seems at the moment the framework is passing us a seemingly valid
                 // but actually non-functional InputConnection object. So if this bug ever gets
@@ -792,6 +807,19 @@
 
     void onStartInputInternal(final EditorInfo editorInfo, final boolean restarting) {
         super.onStartInput(editorInfo, restarting);
+
+        // If the primary hint language does not match the current subtype language, then try
+        // to switch to the primary hint language.
+        // TODO: Support all the locales in EditorInfo#hintLocales.
+        final Locale primaryHintLocale = EditorInfoCompatUtils.getPrimaryHintLocale(editorInfo);
+        if (primaryHintLocale == null) {
+            return;
+        }
+        final InputMethodSubtype newSubtype = mRichImm.findSubtypeByLocale(primaryHintLocale);
+        if (newSubtype == null || newSubtype.equals(mRichImm.getCurrentSubtype().getRawSubtype())) {
+            return;
+        }
+        mHandler.postSwitchLanguage(newSubtype);
     }
 
     @SuppressWarnings("deprecation")
@@ -877,7 +905,7 @@
         // can go into the correct mode, so we need to do some housekeeping here.
         final boolean needToCallLoadKeyboardLater;
         final Suggest suggest = mInputLogic.mSuggest;
-        if (!currentSettingsValues.mHasHardwareKeyboard) {
+        if (!isImeSuppressedByHardwareKeyboard()) {
             // The app calling setText() has the effect of clearing the composing
             // span, so we should reset our state unconditionally, even if restarting is true.
             // We also tell the input logic about the combining rules for the current subtype, so
@@ -966,12 +994,19 @@
     }
 
     @Override
+    public void onWindowShown() {
+        super.onWindowShown();
+        setNavigationBarVisibility(isInputViewShown());
+    }
+
+    @Override
     public void onWindowHidden() {
         super.onWindowHidden();
         final MainKeyboardView mainKeyboardView = mKeyboardSwitcher.getMainKeyboardView();
         if (mainKeyboardView != null) {
             mainKeyboardView.closing();
         }
+        setNavigationBarVisibility(false);
     }
 
     void onFinishInputInternal() {
@@ -1121,8 +1156,7 @@
             return;
         }
         final int inputHeight = mInputView.getHeight();
-        final boolean hasHardwareKeyboard = settingsValues.mHasHardwareKeyboard;
-        if (hasHardwareKeyboard && visibleKeyboardView.getVisibility() == View.GONE) {
+        if (isImeSuppressedByHardwareKeyboard() && !visibleKeyboardView.isShown()) {
             // If there is a hardware keyboard and a visible software keyboard view has been hidden,
             // no visual element will be shown on the screen.
             outInsets.contentTopInsets = inputHeight;
@@ -1168,7 +1202,7 @@
 
     @Override
     public boolean onShowInputRequested(final int flags, final boolean configChange) {
-        if (Settings.getInstance().getCurrent().mHasHardwareKeyboard) {
+        if (isImeSuppressedByHardwareKeyboard()) {
             return true;
         }
         return super.onShowInputRequested(flags, configChange);
@@ -1185,7 +1219,7 @@
     @Override
     public boolean onEvaluateFullscreenMode() {
         final SettingsValues settingsValues = mSettings.getCurrent();
-        if (settingsValues.mHasHardwareKeyboard) {
+        if (isImeSuppressedByHardwareKeyboard()) {
             // If there is a hardware keyboard, disable full screen mode.
             return false;
         }
@@ -1292,6 +1326,11 @@
         return mOptionsDialog != null && mOptionsDialog.isShowing();
     }
 
+    public void switchLanguage(final InputMethodSubtype subtype) {
+        final IBinder token = getWindow().getWindow().getAttributes().token;
+        mRichImm.setInputMethodAndSubtype(token, subtype);
+    }
+
     // TODO: Revise the language switch key behavior to make it much smarter and more reasonable.
     public void switchToNextSubtype() {
         final IBinder token = getWindow().getWindow().getAttributes().token;
@@ -1649,7 +1688,10 @@
     // Hooks for hardware keyboard
     @Override
     public boolean onKeyDown(final int keyCode, final KeyEvent keyEvent) {
-        // TODO: This should be processed in {@link InputLogic}.
+        if (mEmojiAltPhysicalKeyDetector == null) {
+            mEmojiAltPhysicalKeyDetector = new EmojiAltPhysicalKeyDetector(
+                    getApplicationContext().getResources());
+        }
         mEmojiAltPhysicalKeyDetector.onKeyDown(keyEvent);
         if (!ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) {
             return super.onKeyDown(keyCode, keyEvent);
@@ -1671,7 +1713,10 @@
 
     @Override
     public boolean onKeyUp(final int keyCode, final KeyEvent keyEvent) {
-        // TODO: This should be processed in {@link InputLogic}.
+        if (mEmojiAltPhysicalKeyDetector == null) {
+            mEmojiAltPhysicalKeyDetector = new EmojiAltPhysicalKeyDetector(
+                    getApplicationContext().getResources());
+        }
         mEmojiAltPhysicalKeyDetector.onKeyUp(keyEvent);
         if (!ProductionFlags.IS_HARDWARE_KEYBOARD_SUPPORTED) {
             return super.onKeyUp(keyCode, keyEvent);
@@ -1863,4 +1908,13 @@
         }
         return mRichImm.shouldOfferSwitchingToNextInputMethod(token, fallbackValue);
     }
+
+    private void setNavigationBarVisibility(final boolean visible) {
+        if (BuildCompatUtils.EFFECTIVE_SDK_INT > Build.VERSION_CODES.M) {
+            // For N and later, IMEs can specify Color.TRANSPARENT to make the navigation bar
+            // transparent.  For other colors the system uses the default color.
+            getWindow().getWindow().setNavigationBarColor(
+                    visible ? Color.BLACK : Color.TRANSPARENT);
+        }
+    }
 }
diff -ru app/src/main/java/com/android/inputmethod/latin/RichInputMethodManager.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/RichInputMethodManager.java
--- app/src/main/java/com/android/inputmethod/latin/RichInputMethodManager.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/RichInputMethodManager.java	2017-05-27 13:16:01.000000000 +1000
@@ -32,6 +32,7 @@
 
 import com.android.inputmethod.annotations.UsedForTesting;
 import com.android.inputmethod.compat.InputMethodManagerCompatWrapper;
+import com.android.inputmethod.compat.InputMethodSubtypeCompatUtils;
 import com.android.inputmethod.latin.settings.Settings;
 import com.android.inputmethod.latin.utils.AdditionalSubtypeUtils;
 import com.android.inputmethod.latin.utils.LanguageOnSpacebarUtils;
@@ -428,6 +429,46 @@
         return null;
     }
 
+    public InputMethodSubtype findSubtypeByLocale(final Locale locale) {
+        // Find the best subtype based on a straightforward matching algorithm.
+        // TODO: Use LocaleList#getFirstMatch() instead.
+        final List<InputMethodSubtype> subtypes =
+                getMyEnabledInputMethodSubtypeList(true /* allowsImplicitlySelectedSubtypes */);
+        final int count = subtypes.size();
+        for (int i = 0; i < count; ++i) {
+            final InputMethodSubtype subtype = subtypes.get(i);
+            final Locale subtypeLocale = InputMethodSubtypeCompatUtils.getLocaleObject(subtype);
+            if (subtypeLocale.equals(locale)) {
+                return subtype;
+            }
+        }
+        for (int i = 0; i < count; ++i) {
+            final InputMethodSubtype subtype = subtypes.get(i);
+            final Locale subtypeLocale = InputMethodSubtypeCompatUtils.getLocaleObject(subtype);
+            if (subtypeLocale.getLanguage().equals(locale.getLanguage()) &&
+                    subtypeLocale.getCountry().equals(locale.getCountry()) &&
+                    subtypeLocale.getVariant().equals(locale.getVariant())) {
+                return subtype;
+            }
+        }
+        for (int i = 0; i < count; ++i) {
+            final InputMethodSubtype subtype = subtypes.get(i);
+            final Locale subtypeLocale = InputMethodSubtypeCompatUtils.getLocaleObject(subtype);
+            if (subtypeLocale.getLanguage().equals(locale.getLanguage()) &&
+                    subtypeLocale.getCountry().equals(locale.getCountry())) {
+                return subtype;
+            }
+        }
+        for (int i = 0; i < count; ++i) {
+            final InputMethodSubtype subtype = subtypes.get(i);
+            final Locale subtypeLocale = InputMethodSubtypeCompatUtils.getLocaleObject(subtype);
+            if (subtypeLocale.getLanguage().equals(locale.getLanguage())) {
+                return subtype;
+            }
+        }
+        return null;
+    }
+
     public void setInputMethodAndSubtype(final IBinder token, final InputMethodSubtype subtype) {
         mImmWrapper.mImm.setInputMethodAndSubtype(
                 token, getInputMethodIdOfThisIme(), subtype);
diff -ru app/src/main/java/com/android/inputmethod/latin/RichInputMethodSubtype.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/RichInputMethodSubtype.java
--- app/src/main/java/com/android/inputmethod/latin/RichInputMethodSubtype.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/RichInputMethodSubtype.java	2017-05-27 13:16:01.000000000 +1000
@@ -18,14 +18,17 @@
 
 import static com.android.inputmethod.latin.common.Constants.Subtype.KEYBOARD_MODE;
 
+import android.os.Build;
 import android.util.Log;
 import android.view.inputmethod.InputMethodSubtype;
 
+import com.android.inputmethod.compat.BuildCompatUtils;
 import com.android.inputmethod.compat.InputMethodSubtypeCompatUtils;
 import com.android.inputmethod.latin.common.Constants;
 import com.android.inputmethod.latin.common.LocaleUtils;
 import com.android.inputmethod.latin.utils.SubtypeLocaleUtils;
 
+import java.util.HashMap;
 import java.util.Locale;
 
 import javax.annotation.Nonnull;
@@ -40,14 +43,29 @@
 public class RichInputMethodSubtype {
     private static final String TAG = RichInputMethodSubtype.class.getSimpleName();
 
+    private static final HashMap<Locale, Locale> sLocaleMap = initializeLocaleMap();
+    private static final HashMap<Locale, Locale> initializeLocaleMap() {
+        final HashMap<Locale, Locale> map = new HashMap<>();
+        if (BuildCompatUtils.EFFECTIVE_SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            // Locale#forLanguageTag is available on API Level 21+.
+            // TODO: Remove this workaround once when we become able to deal with "sr-Latn".
+            map.put(Locale.forLanguageTag("sr-Latn"), new Locale("sr_ZZ"));
+        }
+        return map;
+    }
+
     @Nonnull
     private final InputMethodSubtype mSubtype;
     @Nonnull
     private final Locale mLocale;
+    @Nonnull
+    private final Locale mOriginalLocale;
 
     public RichInputMethodSubtype(@Nonnull final InputMethodSubtype subtype) {
         mSubtype = subtype;
-        mLocale = LocaleUtils.constructLocaleFromString(mSubtype.getLocale());
+        mOriginalLocale = InputMethodSubtypeCompatUtils.getLocaleObject(mSubtype);
+        final Locale mappedLocale = sLocaleMap.get(mOriginalLocale);
+        mLocale = mappedLocale != null ? mappedLocale : mOriginalLocale;
     }
 
     // Extra values are determined by the primary subtype. This is probably right, but
@@ -128,6 +146,11 @@
         return mLocale;
     }
 
+    @Nonnull
+    public Locale getOriginalLocale() {
+        return mOriginalLocale;
+    }
+
     public boolean isRtlSubtype() {
         // The subtype is considered RTL if the language of the main subtype is RTL.
         return LocaleUtils.isRtlLanguage(mLocale);
Only in app/src/main/java/com/android/inputmethod/latin: about
Only in app/src/main/java/com/android/inputmethod/latin/accounts: AccountStateChangedListener.java
Only in app/src/main/java/com/android/inputmethod/latin/accounts: LoginAccountUtils.java
Only in app/src/main/java/com/android/inputmethod/latin: common
Only in app/src/main/java/com/android/inputmethod/latin: define
Only in app/src/main/java/com/android/inputmethod/latin/settings: AdditionalFeaturesSettingUtils.java
diff -ru app/src/main/java/com/android/inputmethod/latin/settings/SettingsFragment.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/settings/SettingsFragment.java
--- app/src/main/java/com/android/inputmethod/latin/settings/SettingsFragment.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/settings/SettingsFragment.java	2017-05-27 13:16:02.000000000 +1000
@@ -53,9 +53,7 @@
                 ApplicationUtils.getActivityTitleResId(getActivity(), SettingsActivity.class));
         if (!ProductionFlags.ENABLE_ACCOUNT_SIGN_IN) {
             final Preference accountsPreference = findPreference(Settings.SCREEN_ACCOUNTS);
-            if (accountsPreference != null) {
-                preferenceScreen.removePreference(accountsPreference);
-            }
+            preferenceScreen.removePreference(accountsPreference);
         }
     }
 
diff -ru app/src/main/java/com/android/inputmethod/latin/settings/SettingsValues.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/settings/SettingsValues.java
--- app/src/main/java/com/android/inputmethod/latin/settings/SettingsValues.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/settings/SettingsValues.java	2017-05-27 13:16:02.000000000 +1000
@@ -367,7 +367,7 @@
                     .remove(Settings.PREF_VOICE_MODE_OBSOLETE)
                     .apply();
         }
-        return prefs.getBoolean(Settings.PREF_VOICE_INPUT_KEY, false);
+        return prefs.getBoolean(Settings.PREF_VOICE_INPUT_KEY, true);
     }
 
     public String dump() {
diff -ru app/src/main/java/com/android/inputmethod/latin/setup/SetupWizardActivity.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/setup/SetupWizardActivity.java
--- app/src/main/java/com/android/inputmethod/latin/setup/SetupWizardActivity.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/setup/SetupWizardActivity.java	2017-05-27 13:16:02.000000000 +1000
@@ -50,18 +50,16 @@
 
     // For debugging purpose.
     private static final boolean FORCE_TO_SHOW_WELCOME_SCREEN = false;
-    private static final boolean ENABLE_WELCOME_VIDEO = false;
+    private static final boolean ENABLE_WELCOME_VIDEO = true;
 
     private InputMethodManager mImm;
 
     private View mSetupWizard;
     private View mWelcomeScreen;
     private View mSetupScreen;
-    /*
     private Uri mWelcomeVideoUri;
     private VideoView mWelcomeVideoView;
     private ImageView mWelcomeImageView;
-    */
     private View mActionStart;
     private View mActionNext;
     private TextView mStep1Bullet;
@@ -193,7 +191,6 @@
         });
         mSetupStepGroup.addStep(step3);
 
-        /*
         mWelcomeVideoUri = new Uri.Builder()
                 .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
                 .authority(getPackageName())
@@ -219,7 +216,6 @@
         });
         mWelcomeVideoView = welcomeVideoView;
         mWelcomeImageView = (ImageView)findViewById(R.id.setup_welcome_image);
-        */
 
         mActionStart = findViewById(R.id.setup_start_label);
         mActionStart.setOnClickListener(this);
@@ -380,7 +376,6 @@
         super.onBackPressed();
     }
 
-    /*
     void hideWelcomeVideoAndShowWelcomeImage() {
         mWelcomeVideoView.setVisibility(View.GONE);
         mWelcomeImageView.setImageResource(R.raw.setup_welcome_image);
@@ -397,11 +392,10 @@
         mWelcomeVideoView.stopPlayback();
         mWelcomeVideoView.setVisibility(View.GONE);
     }
-    */
 
     @Override
     protected void onPause() {
-        //hideAndStopWelcomeVideo();
+        hideAndStopWelcomeVideo();
         super.onPause();
     }
 
@@ -420,7 +414,6 @@
         final boolean welcomeScreen = (mStepNumber == STEP_WELCOME);
         mWelcomeScreen.setVisibility(welcomeScreen ? View.VISIBLE : View.GONE);
         mSetupScreen.setVisibility(welcomeScreen ? View.GONE : View.VISIBLE);
-        /*
         if (welcomeScreen) {
             if (ENABLE_WELCOME_VIDEO) {
                 showAndStartWelcomeVideo();
@@ -430,7 +423,6 @@
             return;
         }
         hideAndStopWelcomeVideo();
-        */
         final boolean isStepActionAlreadyDone = mStepNumber < determineSetupStepNumber();
         mSetupStepGroup.enableStep(mStepNumber, isStepActionAlreadyDone);
         mActionNext.setVisibility(isStepActionAlreadyDone ? View.VISIBLE : View.GONE);
Only in app/src/main/java/com/android/inputmethod/latin: touchinputconsumer
Only in app/src/main/java/com/android/inputmethod/latin/utils: DictionaryHeaderUtils.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: FeedbackUtils.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: FileTransforms.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: ManagedProfileUtils.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: MetadataFileUriGetter.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: StatsUtils.java
Only in app/src/main/java/com/android/inputmethod/latin/utils: StatsUtilsManager.java
diff -ru app/src/main/java/com/android/inputmethod/latin/utils/TypefaceUtils.java /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/utils/TypefaceUtils.java
--- app/src/main/java/com/android/inputmethod/latin/utils/TypefaceUtils.java	2017-05-26 16:41:05.000000000 +1000
+++ /Users/brendan/Downloads/LatinIME-384007ac74283c1487e5eee27446a26cce3ce78c/java/src/com/android/inputmethod/latin/utils/TypefaceUtils.java	2017-05-27 13:16:02.000000000 +1000
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2013 The Android Open Source Project
- * Copyright (C) 2015 Brendan Molloy <brendan@bbqsrc.net>
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,57 +16,19 @@
 
 package com.android.inputmethod.latin.utils;
 
-import android.content.Context;
 import android.graphics.Paint;
 import android.graphics.Rect;
 import android.graphics.Typeface;
-import android.os.Build;
-import android.util.Log;
 import android.util.SparseArray;
 
-import com.android.inputmethod.latin.R;
-import com.android.inputmethod.latin.common.StringUtils;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Map;
-
 public final class TypefaceUtils {
-    private static final String TAG = TypefaceUtils.class.getSimpleName();
-
     private static final char[] KEY_LABEL_REFERENCE_CHAR = { 'M' };
     private static final char[] KEY_NUMERIC_HINT_LABEL_REFERENCE_CHAR = { '8' };
 
-    private static final Map<Integer, BitSet> sMissingCodepoints = new HashMap<Integer, BitSet>();
-
     private TypefaceUtils() {
         // This utility class is not publicly instantiable.
     }
 
-    private static byte[] getByteBufferForPath(Context context, int resid) {
-        InputStream is = context.getResources().openRawResource(resid);
-
-        byte[] data = new byte[0];
-
-        try {
-            data = new byte[is.available()];
-            is.read(data);
-            is.close();
-        } catch (IOException e) {
-            Log.e(TAG, "failed to read resid " + resid, e);
-        }
-
-        return data;
-    }
-
-    public static void init(Context context) {
-        sMissingCodepoints.put(16, BitSet.valueOf(getByteBufferForPath(context, R.raw.unicode_api16)));
-        sMissingCodepoints.put(19, BitSet.valueOf(getByteBufferForPath(context, R.raw.unicode_api19)));
-        sMissingCodepoints.put(21, BitSet.valueOf(getByteBufferForPath(context, R.raw.unicode_api21)));
-    }
-
     // This sparse array caches key label text height in pixel indexed by key label text size.
     private static final SparseArray<Float> sTextHeightCache = new SparseArray<>();
     // Working variable for the following method.
@@ -108,38 +69,6 @@
         }
     }
 
-    public static boolean isGlyphDrawable(String glyph) {
-        if (glyph == null) {
-            return false;
-        }
-
-        int sdk = Build.VERSION.SDK_INT;
-
-        if (!sMissingCodepoints.containsKey(sdk)) {
-            int fallback;
-
-            if (sdk > 21 || sdk == 20) {
-                fallback = 21;
-            } else {
-                fallback = 16;
-            }
-
-            Log.w(TAG, String.format("No missing codepoints for API %s; falling back to %s.", sdk, fallback));
-            sdk = fallback;
-        }
-
-        int[] cps = StringUtils.toCodePointArray(glyph);
-        BitSet bs = sMissingCodepoints.get(sdk);
-
-        for (int i = 0; i < cps.length; ++i) {
-            if (!bs.get(cps[i])) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
     private static int getCharGeometryCacheKey(final char referenceChar, final Paint paint) {
         final int labelSize = (int)paint.getTextSize();
         final Typeface face = paint.getTypeface();
Only in app/src/main/java/com/android: inputmethodcommon
